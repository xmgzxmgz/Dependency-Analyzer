const { expect } = require("chai");
const sinon = require("sinon");
const fs = require("fs");
const path = require("path");
const { execSync } = require("child_process");

describe("安全漏洞扫描测试", function () {
  let sandbox;

  beforeEach(function () {
    sandbox = sinon.createSandbox();
  });

  afterEach(function () {
    sandbox.restore();
  });

  describe("依赖安全检查", function () {
    it("应该检查已知的安全漏洞", function () {
      this.timeout(30000);

      try {
        // 运行 npm audit 检查依赖漏洞
        const auditResult = execSync("npm audit --json", {
          cwd: process.cwd(),
          encoding: "utf8",
        });

        const audit = JSON.parse(auditResult);

        // 检查是否有高危或严重漏洞
        if (audit.metadata && audit.metadata.vulnerabilities) {
          const { high, critical } = audit.metadata.vulnerabilities;
          expect(high + critical).to.equal(0, "发现高危或严重安全漏洞");
        }
      } catch (error) {
        // npm audit 可能返回非零退出码，但仍需检查结果
        if (error.stdout) {
          const audit = JSON.parse(error.stdout);
          if (audit.metadata && audit.metadata.vulnerabilities) {
            const { high, critical } = audit.metadata.vulnerabilities;
            expect(high + critical).to.equal(0, "发现高危或严重安全漏洞");
          }
        }
      }
    });

    it("应该检查过时的依赖包", function () {
      this.timeout(20000);

      try {
        const outdatedResult = execSync("npm outdated --json", {
          cwd: process.cwd(),
          encoding: "utf8",
        });

        const outdated = JSON.parse(outdatedResult);
        const criticalPackages = ["express", "lodash", "axios"];

        Object.keys(outdated).forEach((pkg) => {
          if (criticalPackages.includes(pkg)) {
            const { current, latest } = outdated[pkg];
            console.warn(`关键包 ${pkg} 版本过时: ${current} -> ${latest}`);
          }
        });
      } catch (error) {
        // npm outdated 在有过时包时返回非零退出码，这是正常的
        if (error.stdout) {
          const outdated = JSON.parse(error.stdout);
          // 记录但不失败测试
          console.log("发现过时依赖:", Object.keys(outdated).length);
        }
      }
    });
  });

  describe("代码安全扫描", function () {
    it("应该检查硬编码的敏感信息", function () {
      const sensitivePatterns = [
        /password\s*=\s*['"][^'"]+['"]/i,
        /api[_-]?key\s*=\s*['"][^'"]+['"]/i,
        /secret\s*=\s*['"][^'"]+['"]/i,
        /token\s*=\s*['"][^'"]+['"]/i,
        /private[_-]?key\s*=\s*['"][^'"]+['"]/i,
      ];

      const scanDirectory = (dir) => {
        const files = fs.readdirSync(dir);
        const violations = [];

        files.forEach((file) => {
          const filePath = path.join(dir, file);
          const stat = fs.statSync(filePath);

          if (
            stat.isDirectory() &&
            !file.startsWith(".") &&
            file !== "node_modules"
          ) {
            violations.push(...scanDirectory(filePath));
          } else if (
            file.endsWith(".js") ||
            file.endsWith(".ts") ||
            file.endsWith(".json")
          ) {
            try {
              const content = fs.readFileSync(filePath, "utf8");

              sensitivePatterns.forEach((pattern, index) => {
                const matches = content.match(pattern);
                if (matches) {
                  violations.push({
                    file: filePath,
                    pattern: index,
                    match: matches[0],
                  });
                }
              });
            } catch (error) {
              // 忽略读取错误
            }
          }
        });

        return violations;
      };

      const violations = scanDirectory("./src");
      expect(violations).to.be.empty("发现硬编码的敏感信息");
    });

    it("应该检查不安全的函数调用", function () {
      const unsafeFunctions = [
        "eval(",
        "Function(",
        "setTimeout(",
        "setInterval(",
        "document.write(",
        "innerHTML =",
        "outerHTML =",
      ];

      const scanForUnsafeFunctions = (dir) => {
        const files = fs.readdirSync(dir);
        const violations = [];

        files.forEach((file) => {
          const filePath = path.join(dir, file);
          const stat = fs.statSync(filePath);

          if (
            stat.isDirectory() &&
            !file.startsWith(".") &&
            file !== "node_modules"
          ) {
            violations.push(...scanForUnsafeFunctions(filePath));
          } else if (file.endsWith(".js") || file.endsWith(".ts")) {
            try {
              const content = fs.readFileSync(filePath, "utf8");

              unsafeFunctions.forEach((func) => {
                if (content.includes(func)) {
                  violations.push({
                    file: filePath,
                    function: func,
                    line:
                      content
                        .split("\n")
                        .findIndex((line) => line.includes(func)) + 1,
                  });
                }
              });
            } catch (error) {
              // 忽略读取错误
            }
          }
        });

        return violations;
      };

      const violations = scanForUnsafeFunctions("./src");

      // 允许在测试文件中使用某些函数
      const filteredViolations = violations.filter(
        (v) =>
          !v.file.includes("test") &&
          !v.file.includes("spec") &&
          v.function !== "setTimeout(" // setTimeout 在某些场景下是安全的
      );

      expect(filteredViolations).to.be.empty("发现不安全的函数调用");
    });

    it("应该检查SQL注入风险", function () {
      const sqlInjectionPatterns = [
        /query\s*\+\s*['"`]/i,
        /['"`]\s*\+\s*.*\+\s*['"`]/,
        /execute\s*\(\s*['"`].*\+/i,
        /sql\s*=\s*['"`].*\+/i,
      ];

      const scanForSQLInjection = (dir) => {
        const files = fs.readdirSync(dir);
        const violations = [];

        files.forEach((file) => {
          const filePath = path.join(dir, file);
          const stat = fs.statSync(filePath);

          if (
            stat.isDirectory() &&
            !file.startsWith(".") &&
            file !== "node_modules"
          ) {
            violations.push(...scanForSQLInjection(filePath));
          } else if (file.endsWith(".js") || file.endsWith(".ts")) {
            try {
              const content = fs.readFileSync(filePath, "utf8");

              sqlInjectionPatterns.forEach((pattern, index) => {
                const matches = content.match(pattern);
                if (matches) {
                  violations.push({
                    file: filePath,
                    pattern: index,
                    match: matches[0],
                  });
                }
              });
            } catch (error) {
              // 忽略读取错误
            }
          }
        });

        return violations;
      };

      const violations = scanForSQLInjection("./src");
      expect(violations).to.be.empty("发现潜在的SQL注入风险");
    });
  });

  describe("文件权限检查", function () {
    it("应该检查敏感文件的权限", function () {
      const sensitiveFiles = [
        "package.json",
        ".env",
        ".env.local",
        "config.json",
      ];

      sensitiveFiles.forEach((file) => {
        if (fs.existsSync(file)) {
          const stats = fs.statSync(file);
          const mode = stats.mode;

          // 检查文件是否对其他用户可写 (权限位 002)
          const isWorldWritable = (mode & parseInt("002", 8)) !== 0;
          expect(isWorldWritable).to.be.false(
            `${file} 对所有用户可写，存在安全风险`
          );
        }
      });
    });

    it("应该检查配置文件是否包含敏感信息", function () {
      const configFiles = ["package.json", "package-lock.json"];

      configFiles.forEach((file) => {
        if (fs.existsSync(file)) {
          const content = fs.readFileSync(file, "utf8");

          // 检查是否包含敏感URL或密钥
          const sensitivePatterns = [
            /https?:\/\/.*:.*@/, // 包含认证信息的URL
            /"password":\s*"[^"]+"/,
            /"secret":\s*"[^"]+"/,
            /"key":\s*"[^"]+"/,
          ];

          sensitivePatterns.forEach((pattern) => {
            expect(content).to.not.match(pattern, `${file} 包含敏感信息`);
          });
        }
      });
    });
  });

  describe("输入验证测试", function () {
    it("应该测试路径遍历攻击防护", function () {
      const maliciousPaths = [
        "../../../etc/passwd",
        "..\\..\\..\\windows\\system32\\config\\sam",
        "/etc/passwd",
        "C:\\windows\\system32\\config\\sam",
        "....//....//....//etc/passwd",
      ];

      // 这里应该测试应用程序如何处理这些恶意路径
      // 由于这是一个静态分析工具，主要检查是否有适当的路径验证
      const hasPathValidation =
        fs.readFileSync("./src/index.js", "utf8").includes("path.resolve") ||
        fs.readFileSync("./src/index.js", "utf8").includes("path.normalize");

      expect(hasPathValidation).to.be.true("缺少路径验证机制");
    });

    it("应该检查命令注入防护", function () {
      const sourceFiles = ["./src/index.js", "./bin/cli.js"];

      sourceFiles.forEach((file) => {
        if (fs.existsSync(file)) {
          const content = fs.readFileSync(file, "utf8");

          // 检查是否直接执行用户输入
          const dangerousPatterns = [
            /exec\s*\(\s*[^)]*process\.argv/,
            /spawn\s*\(\s*[^)]*process\.argv/,
            /system\s*\(\s*[^)]*process\.argv/,
          ];

          dangerousPatterns.forEach((pattern) => {
            expect(content).to.not.match(
              pattern,
              `${file} 可能存在命令注入风险`
            );
          });
        }
      });
    });
  });

  describe("第三方依赖安全", function () {
    it("应该检查依赖包的完整性", function () {
      const packageLock = JSON.parse(
        fs.readFileSync("./package-lock.json", "utf8")
      );

      // 检查是否所有依赖都有完整性哈希
      const checkIntegrity = (dependencies) => {
        Object.values(dependencies || {}).forEach((dep) => {
          if (dep.resolved && !dep.integrity) {
            console.warn(`依赖 ${dep.resolved} 缺少完整性校验`);
          }

          if (dep.dependencies) {
            checkIntegrity(dep.dependencies);
          }
        });
      };

      checkIntegrity(packageLock.dependencies);
    });

    it("应该检查是否使用了已知的恶意包", function () {
      const knownMaliciousPackages = [
        "event-stream",
        "eslint-scope",
        "getcookies",
        "rc",
      ];

      const packageJson = JSON.parse(fs.readFileSync("./package.json", "utf8"));
      const allDependencies = {
        ...packageJson.dependencies,
        ...packageJson.devDependencies,
      };

      knownMaliciousPackages.forEach((maliciousPackage) => {
        expect(allDependencies).to.not.have.property(
          maliciousPackage,
          `检测到已知恶意包: ${maliciousPackage}`
        );
      });
    });
  });
});
